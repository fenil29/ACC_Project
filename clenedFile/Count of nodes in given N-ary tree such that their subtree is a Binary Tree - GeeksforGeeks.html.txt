Count of nodes in given N-ary tree such that their subtree is a Binary Tree - GeeksforGeeks                                                          Skip to content                                                      Tutorials  Practice DS &amp; Algo.  Must Do Questions DSA Topic-wise DSA Company-wise  Algorithms  Analysis of Algorithms  Asymptotic Analysis Worst, Average and Best Cases Asymptotic Notations Little o and little omega notations Lower and Upper Bound Theory Analysis of Loops Solving Recurrences Amortized Analysis What does 'Space Complexity' mean ? Pseudo-polynomial Algorithms Polynomial Time Approximation Scheme A Time Complexity Question  Searching Algorithms Sorting Algorithms Graph Algorithms Pattern Searching Geometric Algorithms Mathematical Bitwise Algorithms Randomized Algorithms Greedy Algorithms Dynamic Programming Divide and Conquer Backtracking Branch and Bound All Algorithms  Data Structures  Arrays Linked List Stack Queue Binary Tree Binary Search Tree Heap Hashing Graph Advanced Data Structure Matrix Strings All Data Structures  Interview Corner  Company Preparation Top Topics Practice Company Questions Interview Experiences Experienced Interviews Internship Interviews Competititve Programming Design Patterns System Design Tutorial Multiple Choice Quizzes  Languages  C C++ Java Python C# JavaScript jQuery SQL PHP Scala Perl Go Language HTML CSS Kotlin  CS Subjects  Mathematics Operating System DBMS Computer Networks Computer Organization and Architecture Theory of Computation Compiler Design Digital Logic Software Engineering  GATE  GATE Computer Science Notes Last Minute Notes GATE CS Solved Papers GATE CS Original Papers and Official Keys GATE 2021 Dates GATE CS 2021 Syllabus Important Topics for GATE CS  Web Technologies  HTML CSS JavaScript AngularJS ReactJS NodeJS Bootstrap jQuery PHP  Software Designs  Software Design Patterns System Design Tutorial  School Learning  School Programming Mathematics  Number System Algebra Trigonometry Statistics Probability Geometry Mensuration Calculus  Maths Notes (Class 8-12)  Class 8 Notes Class 9 Notes Class 10 Notes Class 11 Notes Class 12 Notes  NCERT Solutions  Class 8 Maths Solution Class 9 Maths Solution Class 10 Maths Solution Class 11 Maths Solution Class 12 Maths Solution  RD Sharma Solutions  Class 8 Maths Solution Class 9 Maths Solution Class 10 Maths Solution Class 11 Maths Solution Class 12 Maths Solution  Physics Notes (Class 8-11)  Class 8 Notes Class 9 Notes Class 10 Notes Class 11 Notes   ISRO CS  ISRO CS Solved Papers ISRO CS Original Papers and Official Keys ISRO CS Syllabus for Scientist/Engineer Exam  UGC NET CS  UGC NET CS Notes Paper II UGC NET CS Notes Paper III UGC NET CS Solved Papers   Student  Campus Ambassador Program School Ambassador Program Project Geek of the Month Campus Geek of the Month Placement Course Competititve Programming Testimonials Geek on the Top Careers Internship  Jobs  Apply for Jobs Post a Job  Courses                    Write   Come write articles for us and get featured         Practice   Learn and code with the best industry experts         Premium   Get access to ad-free content, doubt assistance and more!         Jobs   Come and find your dream job with us       Geeks Digest Quizzes Geeks Campus   Gblog Articles IDE Campus Mantri                Home Saved Videos Courses   GBlog Puzzles What's New ?        Change Language         Data Structures Algorithms Interview Preparation Topic-wise Practice C++ Java Python Competitive Programming Machine Learning Web Development Puzzles Project Ideas School Learning          Related Articles         ?       Related Articles    Tree Traversals (Inorder, Preorder and Postorder) Level Order Binary Tree Traversal AVL Tree | Set 1 (Insertion) Binary Tree | Set 1 (Introduction) Write a Program to Find the Maximum Depth or Height of a Tree Inorder Tree Traversal without Recursion A program to check if a binary tree is BST or not Binary Tree | Set 3 (Types of Binary Tree) Binary Tree | Set 2 (Properties) Lowest Common Ancestor in a Binary Tree | Set 1 Program to count leaf nodes in a binary tree Insertion in a Binary Tree in level order Construct Tree from given Inorder and Preorder traversals BFS vs DFS for Binary Tree Complexity of different operations in Binary tree, Binary Search Tree and AVL tree Deletion in a Binary Tree Print Left View of a Binary Tree Diameter of a Binary Tree How to determine if a binary tree is height-balanced? Segment Tree | Set 1 (Sum of given range) Sorted Array to Balanced BST Print Nodes in Top View of Binary Tree Relationship between number of nodes and height of binary tree Expression Tree Construct a complete binary tree from given array in level order fashion Binary Tree (Array implementation) Inorder Tree Traversal without recursion and without stack! Print a Binary Tree in Vertical Order | Set 2 (Map based Method) Lowest Common Ancestor in a Binary Search Tree. AVL Tree | Set 2 (Deletion)         Table of Contents   Tree Traversals (Inorder, Preorder and Postorder) Level Order Binary Tree Traversal AVL Tree | Set 1 (Insertion) Binary Tree | Set 1 (Introduction) Write a Program to Find the Maximum Depth or Height of a Tree Inorder Tree Traversal without Recursion A program to check if a binary tree is BST or not Binary Tree | Set 3 (Types of Binary Tree) Binary Tree | Set 2 (Properties) Lowest Common Ancestor in a Binary Tree | Set 1 Program to count leaf nodes in a binary tree Insertion in a Binary Tree in level order Construct Tree from given Inorder and Preorder traversals BFS vs DFS for Binary Tree Complexity of different operations in Binary tree, Binary Search Tree and AVL tree Deletion in a Binary Tree Print Left View of a Binary Tree Diameter of a Binary Tree How to determine if a binary tree is height-balanced? Segment Tree | Set 1 (Sum of given range) Sorted Array to Balanced BST Print Nodes in Top View of Binary Tree Relationship between number of nodes and height of binary tree Expression Tree Construct a complete binary tree from given array in level order fashion Binary Tree (Array implementation) Inorder Tree Traversal without recursion and without stack! Print a Binary Tree in Vertical Order | Set 2 (Map based Method) Lowest Common Ancestor in a Binary Search Tree. AVL Tree | Set 2 (Deletion)          Improve Article     Save Article     Like Article     Count of nodes in given N-ary tree such that their subtree is a Binary Tree    Last Updated : 26 Nov, 2021     Given an N-ary tree root, the task is to find the count of nodes such that their subtree is a binary tree. Example:  Attention reader! Don?t stop learning now. Get hold of all the important DSA concepts with the DSA Self Paced Course at a student-friendly price and become industry ready.&nbsp; To complete your preparation from learning a language to DS Algo and many more,&nbsp; please refer Complete Interview Preparation Course. In case you wish to attend live classes with experts, please refer DSA Live Classes for Working Professionals and Competitive Programming Live for Students.   Input: Tree in the image belowOutput: 11Explanation: The nodes such that there subtree is a binary tree are {2, 8, 10, 6, 7, 3, 1, 9, 5, 11, 12}.       Input: Tree in the image belowOutput: 9   &nbsp;  Approach: The given problem can be solved by using the post-order traversal. The idea is to use recursion and check if the current node contains at most 2 children and if the children are valid binary trees. Below steps can be followed to solve the problem:  Apply&nbsp;post-order traversal on the N-ary tree:  Add the returned values of every child node to calculate the number of binary trees found at that node and store it in sum If the root has at most two children which are valid binary trees then the root is also a binary tree, so return a pair of sum + 1 and 1 to indicate a valid binary tree If the root has more than two child nodes or any of the children are not valid binary trees, then return the pair of sum and 0 to indicate an invalid binary tree  Return the value at first index sum, from the pair returned from the post-order traversal.  Below is the implementation of the above approach:  Java                          // Java implementation for the above approach   &nbsp;&nbsp;   import java.io.*;   import java.util.*;   &nbsp;&nbsp;   class GFG {   &nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp; static class Node {   &nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; List&lt;Node&gt; children;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int val;   &nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // constructor   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public Node( int val)   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {   &nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this .val = val;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; children =  new ArrayList&lt;&gt;();   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }   &nbsp;&nbsp;&nbsp;&nbsp; }   &nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp; // Function to find the number of   &nbsp;&nbsp;&nbsp;&nbsp; // binary trees in an N-ary tree   &nbsp;&nbsp;&nbsp;&nbsp; public static int binTreesGeneric(Node root)   &nbsp;&nbsp;&nbsp;&nbsp; {   &nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Base case   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (root ==  null )   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0 ;   &nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Apply post-order traversal on   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the root and return the answer   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return postOrder(root)[ 0 ];   &nbsp;&nbsp;&nbsp;&nbsp; }   &nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp; // Post-order traversal to find   &nbsp;&nbsp;&nbsp;&nbsp; // depth of all branches of every   &nbsp;&nbsp;&nbsp;&nbsp; // node of the tree   &nbsp;&nbsp;&nbsp;&nbsp; public static int [] postOrder(Node root)   &nbsp;&nbsp;&nbsp;&nbsp; {   &nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Initialize a variable sum to   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // count number of binary trees   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int sum =  0 ;   &nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Integer to indicate if the tree   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // rooted at current root is a   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // valid binary tree   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int valid =  1 ;   &nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Use recursion on all child nodes   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (Node child : root.children) {   &nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Get the number of binary trees   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int [] binTrees = postOrder(child);   &nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // If tree rooted at current child   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // is not a valid binary tree then   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // tree rooted at current root is   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // also not a valid binary tree   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (binTrees[ 1 ] ==  0 )   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; valid =  0 ;   &nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // If branches are unbalanced   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // then store -1 in height   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sum += binTrees[ 0 ];   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }   &nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Children are valid binary trees   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // and the number of children   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // are less than 3   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (valid ==  1 &amp;&amp; root.children.size() &lt;  3 ) {   &nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Root is also a valid binary tree   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sum++;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }   &nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Children are leaf nodes but number   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // of children are greater than 2   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; valid =  0 ;   &nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Return the answer   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return new int [] { sum, valid };   &nbsp;&nbsp;&nbsp;&nbsp; }   &nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp; // Driver code   &nbsp;&nbsp;&nbsp;&nbsp; public static void main(String[] args)   &nbsp;&nbsp;&nbsp;&nbsp; {   &nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Initialize the graph   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Node twenty =  new Node( 20 );   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Node seven =  new Node( 7 );   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Node seven2 =  new Node( 7 );   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Node five =  new Node( 5 );   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Node four =  new Node( 4 );   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Node nine =  new Node( 9 );   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Node one =  new Node( 1 );   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Node two =  new Node( 2 );   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Node six =  new Node( 6 );   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Node eight =  new Node( 8 );   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Node ten =  new Node( 10 );   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Node three =  new Node( 3 );   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Node mfour =  new Node( 11 );   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Node zero =  new Node( 12 );   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; three.children.add(mfour);   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; three.children.add(zero);   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ten.children.add(three);   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; two.children.add(six);   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; two.children.add(seven2);   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; four.children.add(nine);   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; four.children.add(one);   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; four.children.add(five);   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; seven.children.add(ten);   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; seven.children.add(two);   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; seven.children.add(eight);   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; seven.children.add(four);   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; twenty.children.add(seven);   &nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Call the function   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // and print the result   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; binTreesGeneric(twenty));   &nbsp;&nbsp;&nbsp;&nbsp; }   }                       Output 11   Time Complexity: O(N)Auxiliary Space: O(N)&nbsp;          My Personal Notes arrow_drop_up      Save           Like      Previous  Maximum count of connected duplicate nodes in given N-ary Tree    Next   Minimise moves to reduce N to 0 using given operations          Recommended Articles     Page :             Count of nodes in a given N-ary tree having distance to all leaf nodes equal in their subtree   26, Nov 21       Convert a Binary Tree such that every node stores the sum of all nodes in its right subtree   20, Jun 18       Minimum number of Nodes to be removed such that no subtree has more than K nodes   10, Aug 20       Print all nodes present in the subtree of a given node of a Binary Tree   08, Feb 21           Check if a binary tree is subtree of another binary tree | Set 1   15, Aug 11       Check if a binary tree is subtree of another binary tree | Set 2   26, Jul 14       Check if a binary tree is subtree of another binary tree using preorder traversal : Iterative   08, Apr 20       Change a Binary Tree so that every node stores sum of all nodes in left subtree   11, Aug 15           Count of nodes having odd divisors in the given subtree for Q queries   22, May 20       Count of Nodes at distance K from S in its subtree for Q queries   05, Jul 21       Subtree of all nodes in a tree using DFS   24, Jul 18       Number of leaf nodes in the subtree of every node of an n-ary tree   26, Nov 18           Find the largest BST subtree in a given Binary Tree | Set 1   17, Feb 12       Subtree with given sum in a Binary Tree   23, Dec 16       Find the largest Complete Subtree in a given Binary Tree   02, May 19       Maximum average of subtree values in a given Binary Tree   25, Dec 20           Check if the given Binary Tree have a Subtree with equal no of 1's and 0's   22, Feb 19       Find the largest Perfect Subtree in a given Binary Tree   01, May 19       Most Frequent Subtree Sum from a given Binary Tree   07, Jan 21       Sum of subtree depths for every node of a given Binary Tree   22, Jan 21           Trim given Binary Tree for any subtree containing only 0s   17, Aug 21       Count of distinct colors in a subtree of a Colored Tree with given min frequency for Q queries   03, Jun 20       Duplicate subtree in Binary Tree | SET 2   30, Aug 19       Check if two nodes are in same subtree of the root node   24, Nov 18                Article Contributed By :         rs1699562   @rs1699562        Vote for difficulty    Easy Normal Medium Hard Expert         Article Tags :   Binary Tree n-ary-tree PostOrder Traversal tree-traversal Tree     Practice Tags :   Tree       Report Issue        Writing code in comment? Please use ide.geeksforgeeks.org, generate link and share the link here.     Load Comments                      What's New              DSA Live Classes for Working Professionals    View Details                 Competitive Programming Live Classes for Students    View Details                 DSA Self Paced Course    View Details                     Most popular in Tree       Decision Tree DFS traversal of a tree using recursion Find maximum (or minimum) in Binary Tree Real-time application of Data Structures Print Postorder traversal from given Inorder and Preorder traversals                    More related articles in Tree       Convert a normal BST to Balanced BST Overview of Data Structures | Set 2 (Binary Tree, BST, Heap and Hash) Maximum Path Sum in a Binary Tree Practice questions on Height balanced/AVL Tree Construct a Binary Tree from Postorder and Inorder                              &times;                                                                       5th Floor, A-118,Sector-136, Noida, Uttar Pradesh - 201305    feedback@geeksforgeeks.org                 Company About Us Careers Privacy Policy Contact Us Copyright Policy   Learn Algorithms Data Structures Languages CS Subjects Video Tutorials   Web Development Web Tutorials HTML CSS JavaScript Bootstrap   Contribute Write an Article Write Interview Experience Internships Videos      @geeksforgeeks , Some rights reserved            We use cookies to ensure you have the best browsing experience on our website. By using our site, you acknowledge that you have read and understood our Cookie Policy &amp; Privacy Policy  Got It !